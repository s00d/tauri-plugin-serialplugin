if("__TAURI__"in window){var __TAURI_PLUGIN_SERIALPLUGIN__=function(t){"use strict";function e(t,e=!1){return window.__TAURI_INTERNALS__.transformCallback(t,e)}async function r(t,e={},r){return window.__TAURI_INTERNALS__.invoke(t,e,r)}var n,i,a,s,o,c;async function l(t,n,i){const a={kind:"Any"};return r("plugin:event|listen",{event:t,target:a,handler:e(n)}).then((e=>async()=>async function(t,e){window.__TAURI_EVENT_PLUGIN_INTERNALS__.unregisterListener(t,e),await r("plugin:event|unlisten",{event:t,eventId:e})}(t,e)))}"function"==typeof SuppressedError&&SuppressedError,function(t){t.WINDOW_RESIZED="tauri://resize",t.WINDOW_MOVED="tauri://move",t.WINDOW_CLOSE_REQUESTED="tauri://close-requested",t.WINDOW_DESTROYED="tauri://destroyed",t.WINDOW_FOCUS="tauri://focus",t.WINDOW_BLUR="tauri://blur",t.WINDOW_SCALE_FACTOR_CHANGED="tauri://scale-change",t.WINDOW_THEME_CHANGED="tauri://theme-changed",t.WINDOW_CREATED="tauri://window-created",t.WEBVIEW_CREATED="tauri://webview-created",t.DRAG_ENTER="tauri://drag-enter",t.DRAG_OVER="tauri://drag-over",t.DRAG_DROP="tauri://drag-drop",t.DRAG_LEAVE="tauri://drag-leave"}(n||(n={}));class u{constructor(){this.enabled=!1,this.interval=5e3,this.maxAttempts=10,this.currentAttempts=0,this.timer=null}async enable(t){this.enabled?console.warn("Auto-reconnect is already enabled"):(this.enabled=!0,this.interval=t.interval||5e3,this.maxAttempts=void 0===t.maxAttempts?10:t.maxAttempts,this.currentAttempts=0,this.callback=t.onReconnect,this.reconnectFunction=t.reconnectFunction,console.log(`Auto-reconnect enabled: interval=${this.interval}ms, maxAttempts=${null===this.maxAttempts?"infinite":this.maxAttempts}`))}async disable(){this.enabled?(this.enabled=!1,this.currentAttempts=0,this.callback=void 0,this.reconnectFunction=void 0,this.timer&&(clearTimeout(this.timer),this.timer=null),console.log("Auto-reconnect disabled")):console.warn("Auto-reconnect is not enabled")}getInfo(){return{enabled:this.enabled,interval:this.interval,maxAttempts:this.maxAttempts,currentAttempts:this.currentAttempts,hasCallback:!!this.callback}}async start(){this.enabled&&this.reconnectFunction&&(this.currentAttempts=0,await this.performAttempt())}async stop(){this.timer&&(clearTimeout(this.timer),this.timer=null)}async reset(){this.currentAttempts=0}async performAttempt(){if(this.enabled&&this.reconnectFunction){if(null!==this.maxAttempts&&this.currentAttempts>=this.maxAttempts)return console.error(`Auto-reconnect failed after ${this.maxAttempts} attempts`),void(this.callback&&this.callback(!1,this.currentAttempts));this.currentAttempts++,console.log(`Auto-reconnect attempt ${this.currentAttempts}${null!==this.maxAttempts?`/${this.maxAttempts}`:""}`);try{if(!await this.reconnectFunction())throw new Error("Reconnect function returned false");console.log("Auto-reconnect successful"),this.currentAttempts=0,this.callback&&this.callback(!0,this.currentAttempts)}catch(t){console.error(`Auto-reconnect attempt ${this.currentAttempts} failed:`,t),this.callback&&this.callback(!1,this.currentAttempts),this.enabled&&(this.timer=setTimeout((()=>{this.performAttempt()}),this.interval))}}}isEnabled(){return this.enabled}getInterval(){return this.interval}getMaxAttempts(){return this.maxAttempts}getCurrentAttempts(){return this.currentAttempts}hasCallback(){return!!this.callback}}class p{constructor(){this.listeners=new Map,this.listenerIdCounter=0}add(t,e){const r=`${t}_${++this.listenerIdCounter}`;return this.listeners.set(r,{unlisten:e,type:t}),()=>{this.delete(r),e()}}set(t,e){return this.listeners.set(t,e),()=>{this.delete(t),e.unlisten()}}delete(t){this.listeners.delete(t)}entries(){return this.listeners.entries()}filterByType(t){return Array.from(this.listeners.entries()).filter((([e,r])=>r.type===t))}all(){return Array.from(this.listeners.entries())}clear(){this.listeners.clear()}getInfo(){const t=this.all(),e=t.filter((([t,e])=>"data"===e.type)),r=t.filter((([t,e])=>"disconnect"===e.type));return{total:t.length,data:e.length,disconnect:r.length,ids:t.map((([t])=>t))}}get(t){return this.listeners.get(t)}}t.DataBits=void 0,(i=t.DataBits||(t.DataBits={})).Five="Five",i.Six="Six",i.Seven="Seven",i.Eight="Eight",t.FlowControl=void 0,(a=t.FlowControl||(t.FlowControl={})).None="None",a.Software="Software",a.Hardware="Hardware",t.Parity=void 0,(s=t.Parity||(t.Parity={})).None="None",s.Odd="Odd",s.Even="Even",t.StopBits=void 0,(o=t.StopBits||(t.StopBits={})).One="One",o.Two="Two",t.ClearBuffer=void 0,(c=t.ClearBuffer||(t.ClearBuffer={})).Input="Input",c.Output="Output",c.All="All";return t.SerialPort=class{constructor(e){this.listeners=new p,this.autoReconnectManager=new u,this.isOpen=!1,this.encoding=e.encoding||"utf-8",this.options={path:e.path,baudRate:e.baudRate,dataBits:e.dataBits||t.DataBits.Eight,flowControl:e.flowControl||t.FlowControl.None,parity:e.parity||t.Parity.None,stopBits:e.stopBits||t.StopBits.One,size:e.size||1024,timeout:e.timeout||200},this.size=e.size||1024}static async available_ports(){try{const t=await r("plugin:serialplugin|available_ports");return Promise.resolve(t)}catch(t){return Promise.reject(t)}}static async available_ports_direct(){try{const t=await r("plugin:serialplugin|available_ports_direct");return Promise.resolve(t)}catch(t){return Promise.reject(t)}}static async managed_ports(){try{const t=await r("plugin:serialplugin|managed_ports");return Promise.resolve(t)}catch(t){return Promise.reject(t)}}static async forceClose(t){return await r("plugin:serialplugin|force_close",{path:t})}static async closeAll(){return await r("plugin:serialplugin|close_all")}async cancelListen(){try{const t=this.listeners.filterByType("data");for(const[e,r]of t)try{"function"==typeof r.unlisten&&r.unlisten()}catch(t){console.warn(`Error unlistening data listener ${e}:`,t)}finally{this.listeners.delete(e)}return}catch(t){return Promise.reject("Failed to cancel serial monitoring: "+t)}}async cancelAllListeners(){try{const t=this.listeners.all();for(const[e,r]of t)try{"function"==typeof r.unlisten&&r.unlisten()}catch(t){console.warn(`Error unlistening listener ${e}:`,t)}finally{this.listeners.delete(e)}return}catch(t){return Promise.reject("Failed to cancel all listeners: "+t)}}getListenersInfo(){return this.listeners.getInfo()}async cancelRead(){try{await r("plugin:serialplugin|cancel_read",{path:this.options.path})}catch(t){return Promise.reject(t instanceof Error?t:new Error(String(t)))}}async change(t){try{let e=!1;return this.isOpen&&(e=!0,await this.close()),t.path&&(this.options.path=t.path),t.baudRate&&(this.options.baudRate=t.baudRate),e&&await this.open(),Promise.resolve()}catch(t){return Promise.reject(t)}}async close(){try{if(!this.isOpen)return;this.autoReconnectManager.isEnabled()&&await this.autoReconnectManager.stop();try{await this.cancelRead()}catch(t){console.warn("Error during cancelRead:",t)}let t;try{t=await r("plugin:serialplugin|close",{path:this.options.path})}catch(t){console.warn("Error during port close:",t)}try{await this.cancelAllListeners()}catch(t){console.warn("Error during cancelAllListeners:",t)}return this.isOpen=!1,t}catch(t){return Promise.reject(t)}}async disconnected(t){let e=this.options.path?.toString().replaceAll(".","-").replaceAll("/","-"),r=`plugin-serialplugin-disconnected-${e}`;console.log("listen event: "+r);const n=await l(r,(()=>{try{t()}catch(t){console.error(t)}}));"function"==typeof n?this.listeners.add("disconnect",n):console.warn("disconnected() did not return a valid unlisten function")}async enableAutoReconnect(t={}){try{await this.autoReconnectManager.enable({...t,reconnectFunction:async()=>{if(this.isOpen)return!0;try{return await this.open(),!0}catch(t){return!1}}}),await this.disconnected((async()=>{this.isOpen=!1,this.autoReconnectManager.isEnabled()&&await this.autoReconnectManager.start()}))}catch(t){return Promise.reject(t)}}async disableAutoReconnect(){try{await this.autoReconnectManager.disable()}catch(t){return Promise.reject(t)}}getAutoReconnectInfo(){return{enabled:this.autoReconnectManager.isEnabled(),interval:this.autoReconnectManager.getInterval(),maxAttempts:this.autoReconnectManager.getMaxAttempts(),currentAttempts:this.autoReconnectManager.getCurrentAttempts(),hasCallback:this.autoReconnectManager.hasCallback()}}async manualReconnect(){try{return this.isOpen?(console.log("Port is already open, no need to reconnect"),!0):(console.log("Manual reconnection attempt..."),await this.open(),console.log("Manual reconnection successful"),!0)}catch(t){return console.error("Manual reconnection failed:",t),!1}}async listen(t,e=!0){try{if(!this.isOpen)return Promise.reject("Port is not open");let r=this.options.path?.toString().replaceAll(".","-").replaceAll("/","-"),n=`plugin-serialplugin-read-${r}`;console.log("listen event: "+n);try{const r=await l(n,(({payload:r})=>{try{if(e){const e=new Uint8Array(r.data);try{const r=new TextDecoder(this.encoding).decode(e);t(r)}catch(r){console.error("Error converting to text with configured encoding:",r);try{const r=new TextDecoder("utf-8").decode(e);t(r)}catch(r){console.error("Fallback decoding also failed:",r),t(String.fromCharCode(...e))}}}else t(new Uint8Array(r.data))}catch(t){console.error(t)}}));return"function"==typeof r?this.listeners.add("data",r):(console.warn("listen() did not return a valid unlisten function"),Promise.reject("Failed to get unlisten function"))}catch(t){throw console.error("Error setting up listener:",t),t}}catch(t){return Promise.reject("Failed to monitor serial port data: "+t)}}async open(){try{if(!this.options.path)return Promise.reject("path Can not be empty!");if(!this.options.baudRate)return Promise.reject("baudRate Can not be empty!");if(this.isOpen)return;const t=await r("plugin:serialplugin|open",{path:this.options.path,baudRate:this.options.baudRate,dataBits:this.options.dataBits,flowControl:this.options.flowControl,parity:this.options.parity,stopBits:this.options.stopBits,timeout:this.options.timeout});return this.isOpen=!0,this.disconnected((()=>{this.isOpen=!1})).catch((t=>console.error(t))),Promise.resolve(t)}catch(t){return Promise.reject(t)}}async startListening(){try{await r("plugin:serialplugin|start_listening",{path:this.options.path,size:this.options.size,timeout:this.options.timeout})}catch(t){return Promise.reject(t)}}async stopListening(){try{await r("plugin:serialplugin|stop_listening",{path:this.options.path})}catch(t){return Promise.reject(t)}}async read(t){try{return this.isOpen?await r("plugin:serialplugin|read",{path:this.options.path,timeout:t?.timeout||this.options.timeout,size:t?.size||this.size}):Promise.reject("Port is not open")}catch(t){return Promise.reject(t)}}async readBinary(t){try{const e=await r("plugin:serialplugin|read_binary",{path:this.options.path,timeout:t?.timeout||this.options.timeout,size:t?.size||this.size});return new Uint8Array(e)}catch(t){return Promise.reject(t)}}async setBaudRate(t){try{return await r("plugin:serialplugin|set_baud_rate",{path:this.options.path,baudRate:t})}catch(t){return Promise.reject(t)}}async setDataBits(t){try{return await r("plugin:serialplugin|set_data_bits",{path:this.options.path,dataBits:t})}catch(t){return Promise.reject(t)}}async setFlowControl(t){try{return await r("plugin:serialplugin|set_flow_control",{path:this.options.path,flowControl:t})}catch(t){return Promise.reject(t)}}async setParity(t){try{return await r("plugin:serialplugin|set_parity",{path:this.options.path,parity:t})}catch(t){return Promise.reject(t)}}async setStopBits(t){try{return await r("plugin:serialplugin|set_stop_bits",{path:this.options.path,stopBits:t})}catch(t){return Promise.reject(t)}}async setTimeout(t){try{return await r("plugin:serialplugin|set_timeout",{path:this.options.path,timeout:t})}catch(t){return Promise.reject(t)}}async setRequestToSend(t){try{return await r("plugin:serialplugin|write_request_to_send",{path:this.options.path,level:t})}catch(t){return Promise.reject(t)}}async setDataTerminalReady(t){try{return await r("plugin:serialplugin|write_data_terminal_ready",{path:this.options.path,level:t})}catch(t){return Promise.reject(t)}}async writeRequestToSend(t){try{return await r("plugin:serialplugin|write_request_to_send",{path:this.options.path,level:t})}catch(t){return Promise.reject(t)}}async writeDataTerminalReady(t){try{return await r("plugin:serialplugin|write_data_terminal_ready",{path:this.options.path,level:t})}catch(t){return Promise.reject(t)}}async readClearToSend(){try{return await r("plugin:serialplugin|read_clear_to_send",{path:this.options.path})}catch(t){return Promise.reject(t)}}async readDataSetReady(){try{return await r("plugin:serialplugin|read_data_set_ready",{path:this.options.path})}catch(t){return Promise.reject(t)}}async readRingIndicator(){try{return await r("plugin:serialplugin|read_ring_indicator",{path:this.options.path})}catch(t){return Promise.reject(t)}}async readCarrierDetect(){try{return await r("plugin:serialplugin|read_carrier_detect",{path:this.options.path})}catch(t){return Promise.reject(t)}}async bytesToRead(){try{return await r("plugin:serialplugin|bytes_to_read",{path:this.options.path})}catch(t){return Promise.reject(t)}}async bytesToWrite(){try{return await r("plugin:serialplugin|bytes_to_write",{path:this.options.path})}catch(t){return Promise.reject(t)}}async clearBuffer(t){try{return await r("plugin:serialplugin|clear_buffer",{path:this.options.path,bufferType:t})}catch(t){return Promise.reject(t)}}async setBreak(){try{return await r("plugin:serialplugin|set_break",{path:this.options.path})}catch(t){return Promise.reject(t)}}async clearBreak(){try{return await r("plugin:serialplugin|clear_break",{path:this.options.path})}catch(t){return Promise.reject(t)}}async write(t){try{return this.isOpen?await r("plugin:serialplugin|write",{value:t,path:this.options.path}):Promise.reject(`serial port ${this.options.path} not opened!`)}catch(t){return Promise.reject(t)}}async writeBinary(t){try{return this.isOpen?t instanceof Uint8Array||t instanceof Array?await r("plugin:serialplugin|write_binary",{value:Array.from(t),path:this.options.path}):Promise.reject("value Argument type error! Expected type: string, Uint8Array, number[]"):Promise.reject(`serial port ${this.options.path} not opened!`)}catch(t){return Promise.reject(t)}}},t}({});Object.defineProperty(window.__TAURI__,"serialplugin",{value:__TAURI_PLUGIN_SERIALPLUGIN__})}
